use chrono::{DateTime, TimeZone, Utc};
use sha1::{Digest, Sha1};
use std::fmt;

pub struct Index {
    pub entries: Vec<Entry>,
}

impl Index {
    pub fn new(entries: Vec<Entry>) -> Self {
        Self { entries }
    }

    pub fn from(bytes: &[u8]) -> Option<Self> {
        // インデックスファイルじゃない
        if &bytes[0..4] != b"DIRC" {
            return None;
        }

        // version 2 にだけ対応
        if hex_to_num(&bytes[4..8]) != 2 {
            return None;
        }

        let entry_num = hex_to_num(&bytes[8..12]);
        let entries = (0..entry_num)
            .try_fold((0, Vec::new()), |(offs, mut vec), _| {
                let entry = Entry::from(&bytes[(12 + offs)..])?;
                let size = entry.size();
                vec.push(entry);
                Some((offs + size, vec))
            })
            .map(|(_, entries)| entries)?;

        Some(Self::new(entries))
    }

    pub fn as_bytes(&self) -> Vec<u8> {
        let header = [
            *b"DIRC",
            [0x00, 0x00, 0x00, 0x02],
            (self.entries.len() as u32).to_be_bytes(),
        ]
        .concat();

        let entries = self
            .entries
            .iter()
            .flat_map(|x| x.as_bytes())
            .collect::<Vec<_>>();

        let content = [header, entries].concat();
        let hash = Vec::from(Sha1::digest(&content).as_slice());

        [content, hash].concat()
    }
}

impl fmt::Display for Index {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.entries.iter().try_for_each(|e| write!(f, "{}\n", e))
    }
}

pub struct Entry {
    pub c_time: DateTime<Utc>,
    pub m_time: DateTime<Utc>,
    pub dev: u32,
    pub inode: u32,
    pub mode: u32,
    pub uid: u32,
    pub gid: u32,
    pub size: u32,
    pub hash: Vec<u8>,
    pub name: String,
}

impl Entry {
    pub fn from(bytes: &[u8]) -> Option<Self> {
        let c_time = hex_to_num(&bytes[0..4]);
        let c_time_nano = hex_to_num(&bytes[4..8]);
        let m_time = hex_to_num(&bytes[8..12]);
        let m_time_nano = hex_to_num(&bytes[12..16]);
        let dev = hex_to_num(&bytes[16..20]);
        let inode = hex_to_num(&bytes[20..24]);
        let mode = hex_to_num(&bytes[24..28]);
        let uid = hex_to_num(&bytes[28..32]);
        let gid = hex_to_num(&bytes[32..36]);
        let size = hex_to_num(&bytes[36..40]);
        let hash = Vec::from(&bytes[40..60]);
        let name_size = hex_to_num(&bytes[60..62]);
        let name = String::from_utf8(Vec::from(&bytes[62..(62 + name_size as usize)])).ok()?;

        Some(Self {
            c_time: Utc.timestamp(c_time.into(), c_time_nano),
            m_time: Utc.timestamp(m_time.into(), m_time_nano),
            dev,
            inode,
            mode,
            uid,
            gid,
            size,
            hash,
            name,
        })
    }

    pub fn size(&self) -> usize {
        let size = 62 + self.name.len();
        size + (8 - size % 8)
    }

    pub fn as_bytes(&self) -> Vec<u8> {
        let ctime = self.c_time.timestamp() as u32;
        let ctime_nano = self.c_time.timestamp_subsec_nanos();
        let mtime = self.m_time.timestamp() as u32;
        let mtime_nano = self.m_time.timestamp_subsec_nanos();

        let meta = [
            ctime, ctime_nano, mtime, mtime_nano, self.dev, self.inode, self.mode, self.uid,
            self.gid, self.size,
        ]
        .iter()
        .flat_map(|&x| Vec::from(x.to_be_bytes()))
        .collect::<Vec<_>>();

        let name_size = self.name.len() as u16;
        let name = self.name.as_bytes();

        let len = 62 + name_size as usize;

        let padding = (0..(8 - len % 8)).map(|_| b'\0').collect::<Vec<_>>();

        [
            meta,
            self.hash.clone(),
            Vec::from(name_size.to_be_bytes()),
            name.to_vec(),
            padding,
        ]
        .concat()
    }
}

impl fmt::Display for Entry {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{} {} 0\t{}",
            num_to_mode(self.mode as u16),
            hex::encode(&self.hash),
            self.name
        )
    }
}

// バイト列になっている値を1つの整数として変換する
// ex: hex_to_num(&[0x00, 0x00, 0x02, 0x62]) -> -0x0262
fn hex_to_num(hex: &[u8]) -> u32 {
    hex.iter()
        .rev()
        .fold((0u32, 1u32), |(sum, offs), &x| {
            (sum + (x as u32 * offs), offs << 8)
        })
        .0
}

fn num_to_mode(val: u16) -> String {
    let file_type = val >> 13;
    let (user, group, other) = {
        let permission = val & 0x01ff;
        let user = (permission & 0x01c0) >> 6;
        let group = (permission & 0x0038) >> 3;
        let other = permission & 0x0007;

        (user, group, other)
    };

    format!("{:03b}{}{}{}", file_type, user, group, other)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex_to_num() {
        assert_eq!(hex_to_num(&[]), 0);
        assert_eq!(hex_to_num(&[0x00, 0x00, 0x00, 0x02]), 2);
        assert_eq!(hex_to_num(&[0x00, 0x00, 0x02, 0x62]), 610);
    }

    #[test]
    fn test_num_to_mode() {
        assert_eq!(num_to_mode(0), String::from("000000"));
        assert_eq!(num_to_mode(33188), String::from("100644"));
    }

    #[test]
    #[should_panic(expected = "range end index 4 out of range for slice of length 0")]
    fn entry_from_panic() {
        Entry::from(b"");
        Entry::from(b"1");
        Entry::from(b"12");
        Entry::from(b"123");
        Entry::from(b"1234");
        Entry::from(b"12345");
    }

    #[test]
    fn entry_from() {
        let bytes = [
            0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01, 0xd8, 0xd8, 0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01,
            0xd8, 0xd8, 0x01, 0x00, 0x00, 0x04, 0x01, 0x9c, 0xd3, 0x5c, 0x00, 0x00, 0x81, 0xa4,
            0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x9d,
            0xe2, 0x9b, 0xb2, 0xd1, 0xd6, 0x43, 0x4b, 0x8b, 0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2,
            0xe4, 0x8c, 0x53, 0x91, 0x00, 0x1b, 0x68, 0x6f, 0x67, 0x65, 0x2f, 0x68, 0x75, 0x67,
            0x61, 0x2f, 0x62, 0x61, 0x72, 0x2f, 0x70, 0x69, 0x79, 0x6f, 0x2f, 0x2e, 0x67, 0x69,
            0x74, 0x6b, 0x65, 0x65, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let oe = Entry::from(&bytes);
        assert!(oe.is_some());
        assert_eq!(oe.unwrap().size(), 96);
    }

    #[test]
    fn entry_as_bytes() {
        let bytes = [
            0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01, 0xd8, 0xd8, 0x5f, 0x54, 0xeb, 0x3e, 0x16, 0x01,
            0xd8, 0xd8, 0x01, 0x00, 0x00, 0x04, 0x01, 0x9c, 0xd3, 0x5c, 0x00, 0x00, 0x81, 0xa4,
            0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x9d,
            0xe2, 0x9b, 0xb2, 0xd1, 0xd6, 0x43, 0x4b, 0x8b, 0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2,
            0xe4, 0x8c, 0x53, 0x91, 0x00, 0x1b, 0x68, 0x6f, 0x67, 0x65, 0x2f, 0x68, 0x75, 0x67,
            0x61, 0x2f, 0x62, 0x61, 0x72, 0x2f, 0x70, 0x69, 0x79, 0x6f, 0x2f, 0x2e, 0x67, 0x69,
            0x74, 0x6b, 0x65, 0x65, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let entry = Entry::from(&bytes).unwrap();
        assert_eq!(entry.as_bytes(), Vec::from(&bytes[..]));
    }

    #[test]
    fn index_from() {
        assert!(Index::from(b"HOGE").is_none());
        assert!(Index::from(&[0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x01]).is_none());

        let bytes = [
            0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x5f, 0x4a,
            0x42, 0x31, 0x07, 0x0c, 0xb5, 0x6a, 0x5f, 0x4a, 0x42, 0x31, 0x07, 0x0c, 0xb5, 0x6a,
            0x01, 0x00, 0x00, 0x04, 0x01, 0x8f, 0xe1, 0xbd, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x13, 0x96, 0xef, 0x6c, 0x0b,
            0x94, 0x4e, 0x24, 0xfc, 0x22, 0xf5, 0x1f, 0x18, 0x13, 0x6c, 0xd6, 0x2f, 0xfd, 0x5b,
            0x0b, 0x8f, 0x00, 0x0a, 0x2e, 0x67, 0x69, 0x74, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x53, 0x1c, 0xf0, 0x32, 0x72,
            0x44, 0x06, 0x5f, 0x53, 0x1c, 0xf0, 0x32, 0x72, 0x44, 0x06, 0x01, 0x00, 0x00, 0x04,
            0x01, 0x92, 0x0d, 0xc7, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00,
            0x00, 0x14, 0x00, 0x00, 0x01, 0x5e, 0xf7, 0xa9, 0xac, 0x08, 0xc2, 0x97, 0x50, 0xad,
            0x7b, 0x6f, 0xe6, 0x96, 0xed, 0x28, 0x8b, 0x62, 0x34, 0x41, 0xfd, 0xbc, 0x00, 0x0a,
            0x43, 0x61, 0x72, 0x67, 0x6f, 0x2e, 0x74, 0x6f, 0x6d, 0x6c, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x5f, 0x50, 0x4f, 0xac, 0x22, 0x80, 0x54, 0x35, 0x5f, 0x50,
            0x4f, 0xac, 0x22, 0x80, 0x54, 0x35, 0x01, 0x00, 0x00, 0x04, 0x01, 0x99, 0x1a, 0x71,
            0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
            0x00, 0x09, 0x11, 0xb4, 0x81, 0xfc, 0x1b, 0x15, 0xa5, 0x9c, 0x2b, 0x55, 0x83, 0x02,
            0x5d, 0x09, 0x8e, 0x11, 0x8b, 0x90, 0xe1, 0x2e, 0x00, 0x09, 0x52, 0x45, 0x41, 0x44,
            0x4d, 0x45, 0x2e, 0x6d, 0x64, 0x00, 0x5f, 0x55, 0x7c, 0xfd, 0x11, 0xc3, 0x75, 0x61,
            0x5f, 0x55, 0x7c, 0xfd, 0x11, 0xc3, 0x75, 0x61, 0x01, 0x00, 0x00, 0x04, 0x01, 0x9a,
            0x04, 0x12, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14,
            0x00, 0x00, 0x25, 0x24, 0x97, 0x04, 0x99, 0x02, 0xe3, 0xf4, 0x4c, 0x0e, 0xd5, 0xc4,
            0xe1, 0xd7, 0xa2, 0x69, 0xf0, 0x42, 0x56, 0xce, 0xcc, 0x51, 0x00, 0x10, 0x73, 0x72,
            0x63, 0x2f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x2f, 0x6d, 0x6f, 0x64, 0x2e, 0x72, 0x73,
            0x00, 0x00, 0x5f, 0x52, 0xee, 0x27, 0x1e, 0x41, 0x92, 0x4a, 0x5f, 0x52, 0xee, 0x27,
            0x1e, 0x41, 0x92, 0x4a, 0x01, 0x00, 0x00, 0x04, 0x01, 0x8f, 0xe1, 0xc0, 0x00, 0x00,
            0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x03, 0xa1,
            0xb2, 0x98, 0x40, 0xf6, 0x70, 0xca, 0x7a, 0x8b, 0x1a, 0xfb, 0x5f, 0x6e, 0x9b, 0x23,
            0x88, 0x98, 0x07, 0xb4, 0x81, 0x26, 0x00, 0x0a, 0x73, 0x72, 0x63, 0x2f, 0x6c, 0x69,
            0x62, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x54,
            0x90, 0xb0, 0x10, 0xf6, 0x2a, 0xc0, 0x5f, 0x54, 0x90, 0xb0, 0x10, 0xf6, 0x2a, 0xc0,
            0x01, 0x00, 0x00, 0x04, 0x01, 0x90, 0x09, 0xa3, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x05, 0xe3, 0x66, 0x67, 0xdb, 0xbb,
            0xdf, 0x59, 0x23, 0x08, 0x81, 0x4e, 0x83, 0x65, 0x14, 0xeb, 0xf6, 0x6d, 0x03, 0x58,
            0xb3, 0x21, 0x00, 0x0b, 0x73, 0x72, 0x63, 0x2f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x72,
            0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x4e, 0xbd, 0x71, 0x24, 0xc8,
            0xb3, 0x69, 0x5f, 0x4e, 0xbd, 0x71, 0x24, 0xc8, 0xb3, 0x69, 0x01, 0x00, 0x00, 0x04,
            0x01, 0x92, 0x6b, 0xf1, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00,
            0x00, 0x14, 0x00, 0x00, 0x03, 0xb8, 0x3e, 0x31, 0xbc, 0x74, 0xba, 0x52, 0x26, 0xd5,
            0xf2, 0x74, 0xb5, 0x09, 0xe3, 0x09, 0xa4, 0x6c, 0x55, 0x15, 0x35, 0x95, 0x00, 0x12,
            0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2f, 0x62, 0x6c, 0x6f,
            0x62, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x50,
            0x82, 0xed, 0x20, 0xa8, 0xe1, 0xb8, 0x5f, 0x50, 0x82, 0xed, 0x20, 0xa8, 0xe1, 0xb8,
            0x01, 0x00, 0x00, 0x04, 0x01, 0x95, 0x70, 0x0d, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x13, 0xdf, 0xf6, 0x77, 0xcb, 0xc7,
            0x39, 0xcb, 0x92, 0x36, 0xee, 0x69, 0x77, 0xdd, 0x11, 0x0b, 0x19, 0x97, 0x16, 0xae,
            0x80, 0x5d, 0x00, 0x14, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
            0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x5f, 0x50, 0x7c, 0xa6, 0x2f, 0xfe, 0xf2, 0x7a, 0x5f, 0x50, 0x7c, 0xa6,
            0x2f, 0xfe, 0xf2, 0x7a, 0x01, 0x00, 0x00, 0x04, 0x01, 0x92, 0x6b, 0xed, 0x00, 0x00,
            0x81, 0xa4, 0x00, 0x00, 0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x05, 0x86,
            0xfd, 0xac, 0x7b, 0x8b, 0xd5, 0x3e, 0x80, 0xc0, 0x95, 0x64, 0x49, 0xf5, 0xc9, 0xda,
            0x13, 0xea, 0x7c, 0xb1, 0x53, 0x9c, 0x00, 0x11, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62,
            0x6a, 0x65, 0x63, 0x74, 0x2f, 0x6d, 0x6f, 0x64, 0x2e, 0x72, 0x73, 0x00, 0x5f, 0x4e,
            0xe6, 0x2d, 0x16, 0xa9, 0x8b, 0x26, 0x5f, 0x4e, 0xe6, 0x2d, 0x16, 0xa9, 0x8b, 0x26,
            0x01, 0x00, 0x00, 0x04, 0x01, 0x93, 0x74, 0x33, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x01, 0xf5, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x0a, 0x1e, 0xda, 0x8b, 0x2d, 0xb1,
            0xdd, 0xa2, 0x7e, 0x83, 0x41, 0x5d, 0x64, 0x38, 0x84, 0x81, 0x13, 0x12, 0xcd, 0x17,
            0x75, 0xb9, 0x00, 0x12, 0x73, 0x72, 0x63, 0x2f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
            0x2f, 0x74, 0x72, 0x65, 0x65, 0x2e, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x54, 0x52, 0x45, 0x45, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x2d, 0x31, 0x20,
            0x31, 0x0a, 0x73, 0x72, 0x63, 0x00, 0x2d, 0x31, 0x20, 0x31, 0x0a, 0x6f, 0x62, 0x6a,
            0x65, 0x63, 0x74, 0x00, 0x2d, 0x31, 0x20, 0x30, 0x0a, 0x01, 0xd4, 0xa6, 0x28, 0xcc,
            0xab, 0x7a, 0x38, 0x71, 0x5e, 0x9e, 0x22, 0x0b, 0x17, 0xc8, 0x89, 0xe0, 0x63, 0xdd,
            0x3b,
        ];

        let oi = Index::from(&bytes);
        assert!(oi.is_some());
        assert_eq!(oi.unwrap().entries.len(), 10);
    }
}
